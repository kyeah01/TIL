# 2019.01.14 (Algorithm_김한욱)

samsung test

IM - 다중반복문 두세개정도를 굴릴 수 있는난이도.

AD - 완전검색, 완전탐색(재귀함수, DP(Dynamic Program - 동적계획법))
​	 greedy한 방식은 지양해야함

PRO - main함수를 주고 함수 구현. 코딩량이 상당함. Linked List, Tree, 주로 구현.

EXPERT - 통과가 문제가 아니라 최적화 등의 문제.

## Intro

---

- 컴퓨터 언어 : C, GO, Python, Java, Ruby ...
브라우저가 돌리면 스크립트구나!
인터프리터는 한줄씩, 컴파일러는 통째로 돌림.
인터프리터방식은 느리다는 단점이 있음.

- C의 역사? 컴퓨터 언어의 역사!
unix를 돌리기 위한 용도
java는 c의 영향을 받은 언어, platform independent함
- 안드로이드는 자바로 만들어져있음.
앱개발하려면 자바를 배워야하나?
- 아이폰 os는 c로 만들어져있음.
마찬가지로 앱스토어 개발하려면 c를 배워야하나???
- python은 Big Data쪽에 강한언어, Library가 잘 되어있음.
- Algorithm입장에서는 어떤 언어든지 별 상관없음
자료구조를 파악하고, 알고리즘을 짜는 것이 중요함.

PyCharm을 사용할 예정!

## Array1 : List

---

  sort방법에 따른 속도차이 - 선택, 버블, 삽입이 제일 느림(대신 제일 쉬움)

   - 알고리즘 - 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
   - 요구사항 분석 > 설계 > 코딩 > 디버깅 > 유지보수

  1. 시간복잡도 : 빅오 표기법
     계수는 생략하고 최고차항의 제곱수만 생각하여 알고리즘을 표현.

     - log N (이진탐색)
     - N (순차탐색)
     - N log N (Quick, merge, heap sort)
     - N^2 (selection, bubble, insert sort)
     - n^3 (모든 쌍 최단 거리)
     - 2^N (부분집합, 멱집합, )
     - N! (TSP - 가장 빠른 길 찾기 : 순열문제)
       최적의 해가 아니더라도 짧은 시간내에 풀 수 없는 문제들은 휴리스틱 탐색을 통해 근사 알고리즘을 구한다.

  2. 완전검색법 - input된 6개의 모든 카드를 나열해본다.
     (만족할때까지 모든 경우의 수를 다 나열해보고 없는경우 False)

     - 완전검색법을 통한 알고리즘찾기 - 순열

     > 6개의 카드를 받아서 Baby-Gin Game의 조건을 만족하는지 알아내야 한다. Triplet과 run을 충족하는지 알아내보자

     ​			- for 문을 가지고 만드는 순열 : for문을 N회 돌리는 방식.

     ​			- 재귀를 가지고 만드는 순열

     -Greedy 알고리즘 - 근사 알고리즘

     > 거스름돈 줄이기 
     >
     > : 거슬러줘야 할 돈이 800원일때, 400원짜리 동전이 존재한다면?

  3. 버블정렬: O(N^2)
     첫번째 원소부터 인접한 원소끼리 자리교환하면서 크기비교. 

     부등호 비교 후 자리 스왑해서 가장 큰 수부터(혹은 가장 작은 수부터) 나열하는 방식을 사용한다.

  4. 카운팅정렬 : O(n+k)

     정수나 정수로 표현할 수 있는 자료형일때 유용하다. 

     인덱스값으로 값을 저장함.

     원본을 건드리지 않는 정렬.

     n값이 비교적 작을 때 좋음.

>  ***실습하기***

## Array2

---

2차원 이상의 다차원 List 다루기

1. 2차원 배열
   - 행부터 서치
   - 열부터 서치
   - 지그재그 서치
   - 델타를 이용한 2차배열 탐색 : 상하좌우로 움직일 수 있는 경우의 탐색
2. 부분집합의 합 : 비트연산자를 활용하여
3. 검색
   탐색 키: 자료를 구별하여 인식할 수 있는 키
   - 순차 검색 : 일렬로 되어있는 자료를 순서대로 검색하는 방법
     		     간단하고 직관적
     		     배열/ 연결 리스트 등 순차구조 자료구조에서 유용
                          검색대상의 수가 많은 경우에는 비효율적
     1. 정렬되어 있지 않은 경우: 첫번째 원소부터 검색대상과 같은 키값이 있는 원소가 있는지 비교하며 찾고, 동일하면 반환(끝까지 갈 수 있기 때문에 **O(n)**이 된다.)
     2. 정렬된 경우 : 키값보다 검색값이 더 커지면(혹은 더 작아지면) 검색을 그만둔다.(마찬가지로 끝까지 갈 수 있기 때문에 **O(n)**이 된다.)
   - 이진 검색 : 반으로 줄여가면서 찾아나가는 방식, 자료는 항상 정렬되어 있어야만 적용할 수 있다. **O(n)**
   - 인덱스 : 물리적인 데이터 구조를 변경하지 않으면서 배열이 sort되었을때의 인덱스 값을 할당하여 정렬된 것 처럼 한다
   - 셀렉션 알고리즘 (선택정렬) : 
   - 해쉬