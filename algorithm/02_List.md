# List (Array)

- sort방법에 따른 속도차이 - 선택, 버블, 삽입이 제일 느림(대신 제일 쉬움)



## 1. 완전검색법 - 모든 방법을 나열해본다.

(만족할때까지 모든 경우의 수를 다 나열해보고 없는경우 False)

- 완전검색법을 통한 알고리즘찾기 - 순열

> 6개의 카드를 받아서 Baby-Gin Game의 조건을 만족하는지 알아내야 한다. Triplet과 run을 충족하는지 알아내보자

​	- for 문을 가지고 만드는 순열 : for문을 N회 돌리는 방식.

​	- 재귀를 가지고 만드는 순열

-Greedy 알고리즘 - 근사 알고리즘

> 거스름돈 줄이기 
>
> : 거슬러줘야 할 돈이 800원일때, 400원짜리 동전이 존재한다면?



## 2. 버블정렬: O(N^2)

첫번째 원소부터 인접한 원소끼리 자리교환하면서 크기비교. 

부등호 비교 후 자리 스왑해서 가장 큰 수부터(혹은 가장 작은 수부터) 나열하는 방식을 사용한다.



## 3. 카운팅정렬 : O(n+k)

정수나 정수로 표현할 수 있는 자료형일때 유용하다. 

인덱스값으로 값을 저장함.

원본을 건드리지 않는 정렬.

n값이 비교적 작을 때 좋음.

>  ***실습하기***



## 4. 2차원 배열

- 행부터 서치
- 열부터 서치
- 지그재그 서치
- 델타를 이용한 2차배열 탐색 : 상하좌우로 움직일 수 있는 경우의 탐색



## 5. 부분집합의 합

: 비트연산자!! 비트가 이진법을 사용하는 연산이기때문에 굳이 math를 import하여 log를 사용하지 않더라도 log값을 구할 수 있다. (1<<j)와 같은 식으로. 마찬가지로 '&', '|'를 활용할 수 있다.



## 6. 검색

탐색 키: 자료를 구별하여 인식할 수 있는 키

- 순차 검색 : 일렬로 되어있는 자료를 순서대로 검색하는 방법
      간단하고 직관적
    		     배열/ 연결 리스트 등 순차구조 자료구조에서 유용
                검색대상의 수가 많은 경우에는 비효율적

  1. 정렬되어 있지 않은 경우: 첫번째 원소부터 검색대상과 같은 키값이 있는 원소가 있는지 비교하며 찾고, 동일하면 반환(끝까지 갈 수 있기 때문에 **O(n)**이 된다.)
  2. 정렬된 경우 : 키값보다 검색값이 더 커지면(혹은 더 작아지면) 검색을 그만둔다.(마찬가지로 끝까지 갈 수 있기 때문에 **O(n)**이 된다.)

- 이진 검색 : 반으로 줄여가면서 찾아나가는 방식, 자료는 항상 정렬되어 있어야만 적용할 수 있다. **O(n)**

- 인덱스 : 물리적인 데이터 구조를 변경하지 않으면서 배열이 sort되었을때의 인덱스 값을 할당하여 정렬된 것 처럼 한다

- 셀렉션 알고리즘: k번째까지 min혹은 max를 찾은 후에 배열의 k번째를 반환하는 알고리즘

     1. 정렬 알고리즘을 이용해 자료를 정렬하고
     2. 원하는 순서에 있는 원소 가져오기

- 선택정렬 : 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환한다. 

     1. 주어진 리스트 중에서 최소값을 찾고
     2. 리스트의 맨 앞에 위치한 값과 그 값을 교환한다.
     3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.

     한마디로 정렬해야 하는 대상이 1차원 배열일 경우 (n-1)!만큼의 연산을 한다. 다시말해 O(n^2).

> 실습하기
